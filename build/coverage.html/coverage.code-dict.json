{"/home/travis/build/npmtest/node-npmtest-jscodeshift/test.js":"/* istanbul instrument in package npmtest_jscodeshift */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/lib.npmtest_jscodeshift.js":"/* istanbul instrument in package npmtest_jscodeshift */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jscodeshift = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jscodeshift = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jscodeshift && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jscodeshift */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jscodeshift\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jscodeshift.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jscodeshift.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jscodeshift.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jscodeshift.__dirname + '/lib.npmtest_jscodeshift.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/index.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\nmodule.exports = require('./dist/core');\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/core.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\nconst Collection = require('./Collection');\n\nconst collections = require('./collections');\nconst getParser = require('./getParser');\nconst matchNode = require('./matchNode');\nconst recast = require('recast');\nconst template = require('./template');\n\nconst Node = recast.types.namedTypes.Node;\nconst NodePath = recast.types.NodePath;\n\n// Register all built-in collections\nfor (var name in collections) {\n  collections[name].register();\n}\n\n/**\n * Main entry point to the tool. The function accepts multiple different kinds\n * of arguments as a convenience. In particular the function accepts either\n *\n * - a string containing source code\n *   The string is parsed with Recast\n * - a single AST node\n * - a single node path\n * - an array of nodes\n * - an array of node paths\n *\n * @exports jscodeshift\n * @param {Node|NodePath|Array|string} source\n * @param {Object} options Options to pass to Recast when passing source code\n * @return {Collection}\n */\nfunction core(source, options) {\n  return typeof source === 'string' ?\n    fromSource(source, options) :\n    fromAST(source);\n}\n\n/**\n * Returns a collection from a node, node path, array of nodes or array of node\n * paths.\n *\n * @ignore\n * @param {Node|NodePath|Array} source\n * @return {Collection}\n */\nfunction fromAST(ast) {\n  if (Array.isArray(ast)) {\n    if (ast[0] instanceof NodePath || ast.length === 0) {\n      return Collection.fromPaths(ast);\n    } else if (Node.check(ast[0])) {\n      return Collection.fromNodes(ast);\n    }\n  } else {\n    if (ast instanceof NodePath) {\n      return Collection.fromPaths([ast]);\n    } else if (Node.check(ast)) {\n      return Collection.fromNodes([ast]);\n    }\n  }\n  throw new TypeError(\n    'Received an unexpected value ' + Object.prototype.toString.call(ast)\n  );\n}\n\nfunction fromSource(source, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!options.parser) {\n    options.parser = getParser();\n  }\n  return fromAST(recast.parse(source, options));\n}\n\n/**\n * Utility function to match a node against a pattern.\n * @augments core\n * @static\n * @param {Node|NodePath|Object} path\n * @parma {Object} filter\n * @return boolean\n */\nfunction match(path, filter) {\n  if (!(path instanceof NodePath)) {\n    if (typeof path.get === 'function') {\n      path = path.get();\n    } else {\n      path = {value: path};\n    }\n  }\n  return matchNode(path.value, filter);\n}\n\nconst plugins = [];\n\n/**\n * Utility function for registering plugins.\n *\n * Plugins are simple functions that are passed the core jscodeshift instance.\n * They should extend jscodeshift by calling `registerMethods`, etc.\n * This method guards against repeated registrations (the plugin callback will only be called once).\n *\n * @augments core\n * @static\n * @param {Function} plugin\n */\nfunction use(plugin) {\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(core);\n  }\n}\n\n/**\n * Returns a version of the core jscodeshift function \"bound\" to a specific\n * parser.\n *\n * @augments core\n * @static\n */\nfunction withParser(parser) {\n  if (typeof parser === 'string') {\n    parser = getParser(parser);\n  }\n\n  const newCore = function(source, options) {\n    if (options && !options.parser) {\n      options.parser = parser;\n    } else {\n      options = {parser};\n    }\n    return core(source, options);\n  };\n\n  return enrichCore(newCore, parser);\n}\n\n/**\n* The ast-types library\n* @external astTypes\n* @see {@link https://github.com/benjamn/ast-types}\n*/\n\nfunction enrichCore(core, parser) {\n  // add builders and types to the function for simple access\n  Object.assign(core, recast.types.namedTypes);\n  Object.assign(core, recast.types.builders);\n  core.registerMethods = Collection.registerMethods;\n  /**\n  * @augments core\n  * @type external:astTypes\n  */\n  core.types = recast.types;\n  core.match = match;\n  core.template = template(parser);\n\n  // add mappings and filters to function\n  core.filters = {};\n  core.mappings = {};\n  for (const name in collections) {\n    if (collections[name].filters) {\n      core.filters[name] = collections[name].filters;\n    }\n    if (collections[name].mappings) {\n      core.mappings[name] = collections[name].mappings;\n    }\n  }\n  core.use = use;\n  core.withParser = withParser;\n  return core;\n}\n\nmodule.exports = enrichCore(core, getParser());\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/Collection.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst recast = require('recast');\nconst _ = require('lodash');\n\nconst astTypes = recast.types;\nvar types = astTypes.namedTypes;\nconst NodePath = astTypes.NodePath;\nconst Node = types.Node;\n\n/**\n * This represents a generic collection of node paths. It only has a generic\n * API to access and process the elements of the list. It doesn't know anything\n * about AST types.\n *\n * @mixes traversalMethods\n * @mixes mutationMethods\n * @mixes transformMethods\n * @mixes globalMethods\n */\nclass Collection {\n\n  /**\n   * @param {Array} paths An array of AST paths\n   * @param {Collection} parent A parent collection\n   * @param {Array} types An array of types all the paths in the collection\n   *  have in common. If not passed, it will be inferred from the paths.\n   * @return {Collection}\n   */\n  constructor(paths, parent, types) {\n    assert.ok(Array.isArray(paths), 'Collection is passed an array');\n    assert.ok(\n      paths.every(p => p instanceof NodePath),\n      'Array contains only paths'\n    );\n    this._parent = parent;\n    this.__paths = paths;\n    if (types && !Array.isArray(types)) {\n      types = _toTypeArray(types);\n    } else if (!types || Array.isArray(types) && types.length === 0) {\n      types = _inferTypes(paths);\n    }\n    this._types = types.length === 0 ? _defaultType : types;\n  }\n\n  /**\n   * Returns a new collection containing the nodes for which the callback\n   * returns true.\n   *\n   * @param {function} callback\n   * @return {Collection}\n   */\n  filter(callback) {\n    return new this.constructor(this.__paths.filter(callback), this);\n  }\n\n  /**\n   * Executes callback for each node/path in the collection.\n   *\n   * @param {function} callback\n   * @return {Collection} The collection itself\n   */\n  forEach(callback) {\n    this.__paths.forEach(\n      (path, i, paths) => callback.call(path, path, i, paths)\n    );\n    return this;\n  }\n\n  /**\n   * Executes the callback for every path in the collection and returns a new\n   * collection from the return values (which must be paths).\n   *\n   * The callback can return null to indicate to exclude the element from the\n   * new collection.\n   *\n   * If an array is returned, the array will be flattened into the result\n   * collection.\n   *\n   * @param {function} callback\n   * @param {Type} type Force the new collection to be of a specific type\n   */\n  map(callback, type) {\n    const paths = [];\n    this.forEach(function(path) {\n      /*jshint eqnull:true*/\n      let result = callback.apply(path, arguments);\n      if (result == null) return;\n      if (!Array.isArray(result)) {\n        result = [result];\n      }\n      for (let i = 0; i < result.length; i++) {\n        if (paths.indexOf(result[i]) === -1) {\n          paths.push(result[i]);\n        }\n      }\n    });\n    return fromPaths(paths, this, type);\n  }\n\n  /**\n   * Returns the number of elements in this collection.\n   *\n   * @return {number}\n   */\n  size() {\n    return this.__paths.length;\n  }\n\n  /**\n   * Returns the number of elements in this collection.\n   *\n   * @return {number}\n   */\n  get length() {\n    return this.__paths.length;\n  }\n\n  /**\n   * Returns an array of AST nodes in this collection.\n   *\n   * @return {Array}\n   */\n  nodes() {\n    return this.__paths.map(p => p.value);\n  }\n\n  paths() {\n    return this.__paths;\n  }\n\n  getAST() {\n    if (this._parent) {\n      return this._parent.getAST();\n    }\n    return this.__paths;\n  }\n\n  toSource(options) {\n    if (this._parent) {\n      return this._parent.toSource(options);\n    }\n    if (this.__paths.length === 1) {\n      return recast.print(this.__paths[0], options).code;\n    } else {\n      return this.__paths.map(p => recast.print(p, options).code);\n    }\n  }\n\n  /**\n   * Returns a new collection containing only the element at position index.\n   *\n   * In case of a negative index, the element is taken from the end:\n   *\n   *   .at(0)  - first element\n   *   .at(-1) - last element\n   *\n   * @param {number} index\n   * @return {Collection}\n   */\n  at(index) {\n    return fromPaths(\n      this.__paths.slice(\n        index,\n        index === -1 ? undefined : index + 1\n      ),\n      this\n    );\n  }\n\n  /**\n   * Proxies to NodePath#get of the first path.\n   *\n   * @param {string|number} ...fields\n   */\n  get() {\n    const path = this.__paths[0];\n    if (!path) {\n      throw Error(\n        'You cannot call \"get\" on a collection with no paths. ' +\n        'Instead, check the \"length\" property first to verify at least 1 path exists.'\n      );\n    }\n    return path.get.apply(path, arguments);\n  }\n\n  /**\n   * Returns the type(s) of the collection. This is only used for unit tests,\n   * I don't think other consumers would need it.\n   *\n   * @return {Array<string>}\n   */\n  getTypes() {\n    return this._types;\n  }\n\n  /**\n   * Returns true if this collection has the type 'type'.\n   *\n   * @param {Type} type\n   * @return {boolean}\n   */\n  isOfType(type) {\n    return !!type && this._types.indexOf(type.toString()) > -1;\n  }\n}\n\n/**\n * Given a set of paths, this infers the common types of all paths.\n * @private\n * @param {Array} paths An array of paths.\n * @return {Type} type An AST type\n */\nfunction _inferTypes(paths) {\n  let _types = [];\n\n  if (paths.length > 0 && Node.check(paths[0].node)) {\n    const nodeType = types[paths[0].node.type];\n    const sameType = paths.length === 1 ||\n      paths.every(path => nodeType.check(path.node));\n\n    if (sameType) {\n      _types = [nodeType.toString()].concat(\n        astTypes.getSupertypeNames(nodeType.toString())\n      );\n    } else {\n      // try to find a common type\n      _types = _.intersection.apply(\n        null,\n        paths.map(path => astTypes.getSupertypeNames(path.node.type))\n      );\n    }\n  }\n\n  return _types;\n}\n\nfunction _toTypeArray(value) {\n  value = !Array.isArray(value) ? [value] : value;\n  value = value.map(v => v.toString());\n  if (value.length > 1) {\n    return _.union(value, _.intersection.apply(\n      null,\n      value.map(type => astTypes.getSupertypeNames(type))\n    ));\n  } else {\n    return value.concat(astTypes.getSupertypeNames(value[0]));\n  }\n}\n\n/**\n * Creates a new collection from an array of node paths.\n *\n * If type is passed, it will create a typed collection if such a collection\n * exists. The nodes or path values must be of the same type.\n *\n * Otherwise it will try to infer the type from the path list. If every\n * element has the same type, a typed collection is created (if it exists),\n * otherwise, a generic collection will be created.\n *\n * @ignore\n * @param {Array} paths An array of paths\n * @param {Collection} parent A parent collection\n * @param {Type} type An AST type\n * @return {Collection}\n */\nfunction fromPaths(paths, parent, type) {\n  assert.ok(\n    paths.every(n => n instanceof NodePath),\n    'Every element in the array should be a NodePath'\n  );\n\n  return new Collection(paths, parent, type);\n}\n\n/**\n * Creates a new collection from an array of nodes. This is a convenience\n * method which converts the nodes to node paths first and calls\n *\n *    Collections.fromPaths(paths, parent, type)\n *\n * @ignore\n * @param {Array} nodes An array of AST nodes\n * @param {Collection} parent A parent collection\n * @param {Type} type An AST type\n * @return {Collection}\n */\nfunction fromNodes(nodes, parent, type) {\n  assert.ok(\n    nodes.every(n => Node.check(n)),\n    'Every element in the array should be a Node'\n  );\n  return fromPaths(\n    nodes.map(n => new NodePath(n)),\n    parent,\n    type\n  );\n}\n\nconst CPt = Collection.prototype;\n\n/**\n * This function adds the provided methods to the prototype of the corresponding\n * typed collection. If no type is passed, the methods are added to\n * Collection.prototype and are available for all collections.\n *\n * @param {Object} methods Methods to add to the prototype\n * @param {Type=} type Optional type to add the methods to\n */\nfunction registerMethods(methods, type) {\n  for (const methodName in methods) {\n    if (!methods.hasOwnProperty(methodName)) {\n      return;\n    }\n    if (hasConflictingRegistration(methodName, type)) {\n      let msg = `There is a conflicting registration for method with name \"${methodName}\".\\nYou tried to register an additional method with `;\n\n      if (type) {\n        msg += `type \"${type.toString()}\".`\n      } else {\n        msg += 'universal type.'\n      }\n\n      msg += '\\nThere are existing registrations for that method with ';\n\n      const conflictingRegistrations = CPt[methodName].typedRegistrations;\n\n      if (conflictingRegistrations) {\n        msg += `type ${Object.keys(conflictingRegistrations).join(', ')}.`;\n      } else {\n        msg += 'universal type.';\n      }\n\n      throw Error(msg);\n    }\n    if (!type) {\n      CPt[methodName] = methods[methodName];\n    } else {\n      type = type.toString();\n      if (!CPt.hasOwnProperty(methodName)) {\n        installTypedMethod(methodName);\n      }\n      var registrations = CPt[methodName].typedRegistrations;\n      registrations[type] = methods[methodName];\n      astTypes.getSupertypeNames(type).forEach(function (name) {\n        registrations[name] = false;\n      });\n    }\n  }\n}\n\nfunction installTypedMethod(methodName) {\n  if (CPt.hasOwnProperty(methodName)) {\n    throw new Error(`Internal Error: \"${methodName}\" method is already installed`);\n  }\n\n  const registrations = {};\n\n  function typedMethod() {\n    const types = Object.keys(registrations);\n\n    for (let i = 0; i < types.length; i++) {\n      const currentType = types[i];\n      if (registrations[currentType] && this.isOfType(currentType)) {\n        return registrations[currentType].apply(this, arguments);\n      }\n    }\n\n    throw Error(\n      `You have a collection of type [${this.getTypes()}]. ` +\n      `\"${methodName}\" is only defined for one of [${types.join('|')}].`\n    );\n  }\n\n  typedMethod.typedRegistrations = registrations;\n\n  CPt[methodName] = typedMethod;\n}\n\nfunction hasConflictingRegistration(methodName, type) {\n  if (!type) {\n    return CPt.hasOwnProperty(methodName);\n  }\n\n  if (!CPt.hasOwnProperty(methodName)) {\n    return false;\n  }\n\n  const registrations = CPt[methodName] && CPt[methodName].typedRegistrations;\n\n  if (!registrations) {\n    return true;\n  }\n\n  type = type.toString();\n\n  if (registrations.hasOwnProperty(type)) {\n    return true;\n  }\n\n  return astTypes.getSupertypeNames(type.toString()).some(function (name) {\n    return !!registrations[name];\n  });\n}\n\nvar _defaultType = [];\n\n/**\n * Sets the default collection type. In case a collection is created form an\n * empty set of paths and no type is specified, we return a collection of this\n * type.\n *\n * @ignore\n * @param {Type} type\n */\nfunction setDefaultCollectionType(type) {\n  _defaultType = _toTypeArray(type);\n}\n\nexports.fromPaths = fromPaths;\nexports.fromNodes = fromNodes;\nexports.registerMethods = registerMethods;\nexports.hasConflictingRegistration = hasConflictingRegistration;\nexports.setDefaultCollectionType = setDefaultCollectionType;\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/collections/index.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\nmodule.exports = {\n  Node: require('./Node'),\n  JSXElement: require('./JSXElement'),\n  VariableDeclarator: require('./VariableDeclarator'),\n};\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/collections/Node.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst _ = require('lodash');\nconst Collection = require('../Collection');\n\nconst matchNode = require('../matchNode');\nconst recast = require('recast');\n\nconst Node = recast.types.namedTypes.Node;\nvar types = recast.types.namedTypes;\n\n/**\n* @mixin\n*/\nconst traversalMethods = {\n\n  /**\n   * Find nodes of a specific type within the nodes of this collection.\n   *\n   * @param {type}\n   * @param {filter}\n   * @return {Collection}\n   */\n  find: function(type, filter) {\n    const paths = [];\n    const visitorMethodName = 'visit' + type;\n\n    const visitor = {};\n    function visit(path) {\n      /*jshint validthis:true */\n      if (!filter || matchNode(path.value, filter)) {\n        paths.push(path);\n      }\n      this.traverse(path);\n    }\n    this.__paths.forEach(function(p, i) {\n      const self = this;\n      visitor[visitorMethodName] = function(path) {\n        if (self.__paths[i] === path) {\n          this.traverse(path);\n        } else {\n          return visit.call(this, path);\n        }\n      };\n      recast.visit(p, visitor);\n    }, this);\n\n    return Collection.fromPaths(paths, this, type);\n  },\n\n  /**\n   * Returns a collection containing the paths that create the scope of the\n   * currently selected paths. Dedupes the paths.\n   *\n   * @return {Collection}\n   */\n  closestScope: function() {\n    return this.map(path => path.scope && path.scope.path);\n  },\n\n  /**\n   * Traverse the AST up and finds the closest node of the provided type.\n   *\n   * @param {Collection}\n   * @param {filter}\n   * @return {Collection}\n   */\n  closest: function(type, filter) {\n    return this.map(function(path) {\n      let parent = path.parent;\n      while (\n        parent &&\n        !(\n          type.check(parent.value) &&\n          (!filter || matchNode(parent.value, filter))\n        )\n      ) {\n        parent = parent.parent;\n      }\n      return parent || null;\n    });\n  },\n\n  /**\n   * Finds the declaration for each selected path. Useful for member expressions\n   * or JSXElements. Expects a callback function that maps each path to the name\n   * to look for.\n   *\n   * If the callback returns a falsey value, the element is skipped.\n   *\n   * @param {function} nameGetter\n   *\n   * @return {Collection}\n   */\n  getVariableDeclarators: function(nameGetter) {\n    return this.map(function(path) {\n      /*jshint curly:false*/\n      let scope = path.scope;\n      if (!scope) return;\n      const name = nameGetter.apply(path, arguments);\n      if (!name) return;\n      scope = scope.lookup(name);\n      if (!scope) return;\n      const bindings = scope.getBindings()[name];\n      if (!bindings) return;\n      const decl = Collection.fromPaths(bindings)\n        .closest(types.VariableDeclarator);\n      if (decl.length === 1) {\n        return decl.paths()[0];\n      }\n    }, types.VariableDeclarator);\n  },\n};\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n* @mixin\n*/\nconst mutationMethods = {\n  /**\n   * Simply replaces the selected nodes with the provided node. If a function\n   * is provided it is executed for every node and the node is replaced with the\n   * functions return value.\n   *\n   * @param {Node|Array<Node>|function} nodes\n   * @return {Collection}\n   */\n  replaceWith: function(nodes) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof nodes === 'function') ? nodes.call(path, path, i) : nodes;\n      path.replace.apply(path, toArray(newNodes));\n    });\n  },\n\n  /**\n   * Inserts a new node before the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertBefore: function(insert) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof insert === 'function') ? insert.call(path, path, i) : insert;\n      path.insertBefore.apply(path, toArray(newNodes));\n    });\n  },\n\n  /**\n   * Inserts a new node after the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertAfter: function(insert) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof insert === 'function') ? insert.call(path, path, i) : insert;\n      path.insertAfter.apply(path, toArray(newNodes));\n    });\n  },\n\n  remove: function() {\n    return this.forEach(path => path.prune());\n  }\n\n};\n\nfunction register() {\n  Collection.registerMethods(traversalMethods, Node);\n  Collection.registerMethods(mutationMethods, Node);\n  Collection.setDefaultCollectionType(Node);\n}\n\nexports.register = _.once(register);\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/matchNode.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst hasOwn =\n  Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\n/**\n * Checks whether needle is a strict subset of haystack.\n *\n * @param {*} haystack Value to test.\n * @param {*} needle Test function or value to look for in `haystack`.\n * @return {bool}\n */\nfunction matchNode(haystack, needle) {\n  if (typeof needle === 'function') {\n    return needle(haystack);\n  }\n  if (isNode(needle) && isNode(haystack)) {\n    return Object.keys(needle).every(function(property) {\n      return (\n        hasOwn(haystack, property) &&\n        matchNode(haystack[property], needle[property])\n      );\n    });\n  }\n  return haystack === needle;\n}\n\nfunction isNode(value) {\n  return typeof value === 'object' && value;\n}\n\nmodule.exports = matchNode;\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/collections/JSXElement.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst _ = require('lodash');\nconst Collection = require('../Collection');\nconst NodeCollection = require('./Node');\n\nconst assert = require('assert');\nconst recast = require('recast');\nconst requiresModule = require('./VariableDeclarator').filters.requiresModule;\n\nconst types = recast.types.namedTypes;\nconst JSXElement = types.JSXElement;\nconst JSXAttribute = types.JSXAttribute;\nconst Literal = types.Literal;\n\n/**\n * Contains filter methods and mutation methods for processing JSXElements.\n * @mixin\n */\nconst globalMethods = {\n  /**\n   * Finds all JSXElements optionally filtered by name\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findJSXElements: function(name) {\n    const nameFilter = name && {openingElement: {name: {name: name}}};\n    return this.find(JSXElement, nameFilter);\n  },\n\n  /**\n   * Finds all JSXElements by module name. Given\n   *\n   *     var Bar = require('Foo');\n   *     <Bar />\n   *\n   * findJSXElementsByModuleName('Foo') will find <Bar />, without having to\n   * know the variable name.\n   */\n  findJSXElementsByModuleName: function(moduleName) {\n    assert.ok(\n      moduleName && typeof moduleName === 'string',\n      'findJSXElementsByModuleName(...) needs a name to look for'\n    );\n\n    return this.find(types.VariableDeclarator)\n      .filter(requiresModule(moduleName))\n      .map(function(path) {\n        const id = path.value.id.name;\n        if (id) {\n          return Collection.fromPaths([path])\n            .closestScope()\n            .findJSXElements(id)\n            .paths();\n        }\n      });\n  }\n};\n\nconst filterMethods = {\n\n  /**\n   * Filter method for attributes.\n   *\n   * @param {Object} attributeFilter\n   * @return {function}\n   */\n  hasAttributes: function(attributeFilter) {\n    const attributeNames = Object.keys(attributeFilter);\n    return function filter(path) {\n      if (!JSXElement.check(path.value)) {\n        return false;\n      }\n      const elementAttributes = Object.create(null);\n      path.value.openingElement.attributes.forEach(function(attr) {\n        if (!JSXAttribute.check(attr) ||\n          !(attr.name.name in attributeFilter)) {\n          return;\n        }\n        elementAttributes[attr.name.name] = attr;\n      });\n\n      return attributeNames.every(function(name) {\n        if (!(name in elementAttributes) ){\n          return false;\n        }\n        const value = elementAttributes[name].value;\n        const expected = attributeFilter[name];\n        const actual = Literal.check(value) ? value.value : value.expression;\n        if (typeof expected === 'function') {\n          return expected(actual);\n        } else {\n          // Literal attribute values are always strings\n          return String(expected) === actual;\n        }\n      });\n    };\n  },\n\n  /**\n   * Filter elements which contain a specific child type\n   *\n   * @param {string} name\n   * @return {function}\n   */\n  hasChildren: function(name) {\n    return function filter(path) {\n      return JSXElement.check(path.value) &&\n        path.value.children.some(\n          child => JSXElement.check(child) &&\n                   child.openingElement.name.name === name\n        );\n    };\n  }\n};\n\n/**\n* @mixin\n*/\nconst traversalMethods = {\n\n  /**\n   * Returns all child nodes, including literals and expressions.\n   *\n   * @return {Collection}\n   */\n  childNodes: function() {\n    const paths = [];\n    this.forEach(function(path) {\n      const children = path.get('children');\n      const l = children.value.length;\n      for (let i = 0; i < l; i++) {\n        paths.push(children.get(i));\n      }\n    });\n    return Collection.fromPaths(paths, this);\n  },\n\n  /**\n   * Returns all children that are JSXElements.\n   *\n   * @return {JSXElementCollection}\n   */\n  childElements: function() {\n    const paths = [];\n    this.forEach(function(path) {\n      const children = path.get('children');\n      const l = children.value.length;\n      for (let i = 0; i < l; i++) {\n        if (types.JSXElement.check(children.value[i])) {\n          paths.push(children.get(i));\n        }\n      }\n    });\n    return Collection.fromPaths(paths, this, JSXElement);\n  },\n};\n\nconst mappingMethods = {\n  /**\n   * Given a JSXElement, returns its \"root\" name. E.g. it would return \"Foo\" for\n   * both <Foo /> and <Foo.Bar />.\n   *\n   * @param {NodePath} path\n   * @return {string}\n   */\n  getRootName: function(path) {\n    let name = path.value.openingElement.name;\n    while (types.JSXMemberExpression.check(name)) {\n      name = name.object;\n    }\n\n    return name && name.name || null;\n  }\n};\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods, types.Node);\n  Collection.registerMethods(traversalMethods, JSXElement);\n}\n\nexports.register = _.once(register);\nexports.filters = filterMethods;\nexports.mappings = mappingMethods;\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/collections/VariableDeclarator.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst _ = require('lodash');\nconst Collection = require('../Collection');\nconst NodeCollection = require('./Node');\nconst matchNode = require('../matchNode');\nconst recast = require('recast');\n\nconst astNodesAreEquivalent = recast.types.astNodesAreEquivalent;\nconst b = recast.types.builders;\nvar types = recast.types.namedTypes;\n\nconst VariableDeclarator = recast.types.namedTypes.VariableDeclarator;\n\n/**\n* @mixin\n*/\nconst globalMethods = {\n  /**\n   * Finds all variable declarators, optionally filtered by name.\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findVariableDeclarators: function(name) {\n    const filter = name ? {id: {name: name}} : null;\n    return this.find(VariableDeclarator, filter);\n  }\n};\n\nconst filterMethods = {\n  /**\n   * Returns a function that returns true if the provided path is a variable\n   * declarator and requires one of the specified module names.\n   *\n   * @param {string|Array} names A module name or an array of module names\n   * @return {Function}\n   */\n  requiresModule: function(names) {\n    if (names && !Array.isArray(names)) {\n      names = [names];\n    }\n    const requireIdentifier = b.identifier('require');\n    return function(path) {\n      const node = path.value;\n      if (!VariableDeclarator.check(node) ||\n          !types.CallExpression.check(node.init) ||\n          !astNodesAreEquivalent(node.init.callee, requireIdentifier)) {\n        return false;\n      }\n      return !names ||\n        names.some(\n          n => astNodesAreEquivalent(node.init.arguments[0], b.literal(n))\n        );\n    };\n  }\n};\n\n/**\n* @mixin\n*/\nconst transformMethods = {\n  /**\n   * Renames a variable and all its occurrences.\n   *\n   * @param {string} newName\n   * @return {Collection}\n   */\n  renameTo: function(newName) {\n    // TODO: Include JSXElements\n    return this.forEach(function(path) {\n      const node = path.value;\n      const oldName = node.id.name;\n      const rootScope = path.scope;\n      const rootPath = rootScope.path;\n      Collection.fromPaths([rootPath])\n        .find(types.Identifier, {name: oldName})\n        .filter(function(path) { // ignore non-variables\n          const parent = path.parent.node;\n\n          if (\n            types.MemberExpression.check(parent) &&\n            parent.property === path.node &&\n            !parent.computed\n          ) {\n            // obj.oldName\n            return false;\n          }\n\n          if (\n            types.Property.check(parent) &&\n            parent.key === path.node &&\n            !parent.computed\n          ) {\n            // { oldName: 3 }\n            return false;\n          }\n\n          if (\n            types.MethodDefinition.check(parent) &&\n            parent.key === path.node &&\n            !parent.computed\n          ) {\n            // class A { oldName() {} }\n            return false;\n          }\n\n          return true;\n        })\n        .forEach(function(path) {\n          let scope = path.scope;\n          while (scope && scope !== rootScope) {\n            if (scope.declares(oldName)) {\n              return;\n            }\n            scope = scope.parent;\n          }\n          if (scope) { // identifier must refer to declared variable\n            path.get('name').replace(newName);\n          }\n        });\n    });\n  }\n};\n\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods);\n  Collection.registerMethods(transformMethods, VariableDeclarator);\n}\n\nexports.register = _.once(register);\nexports.filters = filterMethods;\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/getParser.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = function getParser(parserName) {\n  switch (parserName) {\n    case 'babylon':\n      return require('../parser/babylon');\n    case 'flow':\n      return require('../parser/flow');\n    case 'babel':\n    default:\n      return require('babel-core');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/dist/template.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst recast = require('recast');\n\nconst builders = recast.types.builders;\nconst types = recast.types.namedTypes;\n\nfunction splice(arr, element, replacement) {\n  arr.splice.apply(arr, [arr.indexOf(element), 1].concat(replacement));\n}\n\nfunction cleanLocation(node) {\n  delete node.start;\n  delete node.end;\n  delete node.loc;\n  return node;\n}\n\nfunction ensureStatement(node) {\n  return types.Statement.check(node) ?\n    // Removing the location information seems to ensure that the node is\n    // correctly reprinted with a trailing semicolon\n    cleanLocation(node) :\n    builders.expressionStatement(node);\n}\n\nfunction getVistor(varNames, nodes) {\n  return {\n    visitIdentifier: function(path) {\n      this.traverse(path);\n      const node = path.node;\n      const parent = path.parent.node;\n\n      // If this identifier is not one of our generated ones, do nothing\n      const varIndex = varNames.indexOf(node.name);\n      if (varIndex === -1) {\n        return;\n      }\n\n      let replacement = nodes[varIndex];\n      nodes[varIndex] = null;\n\n      // If the replacement is an array, we need to explode the nodes in context\n      if (Array.isArray(replacement)) {\n\n        if (types.Function.check(parent) &&\n            parent.params.indexOf(node) > -1) {\n          // Function parameters: function foo(${bar}) {}\n          splice(parent.params, node, replacement);\n        } else if (types.VariableDeclarator.check(parent)) {\n          // Variable declarations: var foo = ${bar}, baz = 42;\n          splice(\n            path.parent.parent.node.declarations,\n            parent,\n            replacement\n          );\n        } else if (types.ArrayExpression.check(parent)) {\n          // Arrays: var foo = [${bar}, baz];\n          splice(parent.elements, node, replacement);\n        } else if (types.Property.check(parent) && parent.shorthand) {\n          // Objects: var foo = {${bar}, baz: 42};\n          splice(\n            path.parent.parent.node.properties,\n            parent,\n            replacement\n          );\n        } else if (types.CallExpression.check(parent) &&\n            parent.arguments.indexOf(node) > -1) {\n          // Function call arguments: foo(${bar}, baz)\n          splice(parent.arguments, node, replacement);\n        } else if (types.ExpressionStatement.check(parent)) {\n          // Generic sequence of statements: { ${foo}; bar; }\n          path.parent.replace.apply(\n            path.parent,\n            replacement.map(ensureStatement)\n          );\n        } else {\n          // Every else, let recast take care of it\n          path.replace.apply(path, replacement);\n        }\n      } else if (types.ExpressionStatement.check(parent)) {\n        path.parent.replace(ensureStatement(replacement));\n      } else {\n        path.replace(replacement);\n      }\n    }\n  };\n}\n\nfunction replaceNodes(src, varNames, nodes, parser) {\n  const ast = recast.parse(src, {parser});\n  recast.visit(ast, getVistor(varNames, nodes));\n  return ast;\n}\n\nfunction getRandomVarName() {\n  return `$jscodeshift${Math.floor(Math.random() * 1000)}$`;\n}\n\n\nmodule.exports = function withParser(parser) {\n  function statements(template/*, ...nodes*/) {\n    template = Array.from(template);\n    const nodes = Array.from(arguments).slice(1);\n    const varNames = nodes.map(n => getRandomVarName());\n    const src = template.reduce(\n      (result, elem, i) => result + varNames[i - 1] + elem\n    );\n\n    return replaceNodes(\n      src,\n      varNames,\n      nodes,\n      parser\n    ).program.body;\n  }\n\n  function statement(/*template, ...nodes*/) {\n    return statements.apply(null, arguments)[0];\n  }\n\n  function expression(template/*, ...nodes*/) {\n    // wrap code in `(...)` to force evaluation as expression\n    template = Array.from(template);\n    if (template.length > 1) {\n      template[0] = '(' + template[0];\n      template[template.length - 1] += ')';\n    } else if (template.length === 0) {\n      template[0] = '(' + template[0] + ')';\n    }\n\n    return statement.apply(\n      null,\n      [template].concat(Array.from(arguments).slice(1))\n    ).expression;\n  }\n\n  return {statements, statement, expression};\n}\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/parser/babylon.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst babylon = require('babylon');\n\nconst options = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  plugins: [\n    'jsx',\n    'flow',\n    'asyncFunctions',\n    'classConstructorCall',\n    'doExpressions',\n    'trailingFunctionCommas',\n    'objectRestSpread',\n    'decorators',\n    'classProperties',\n    'exportExtensions',\n    'exponentiationOperator',\n    'asyncGenerators',\n    'functionBind',\n    'functionSent',\n  ],\n};\n\n/**\n * Wrapper to set default options\n */\nexports.parse = function parse (code) {\n  return babylon.parse(code, options);\n};\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/parser/flow.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst flowParser = require('flow-parser');\n\nconst options = {\n  esproposal_class_instance_fields: true,\n  esproposal_class_static_fields: true,\n  esproposal_decorators: true,\n  esproposal_export_star_as: true,\n  types: true,\n};\n\n/**\n * Wrapper to set default options\n */\nexports.parse = function parse(code) {\n  return flowParser.parse(code, options);\n};\n\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/utils/requirePackage.js":"/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst path = require('path');\n\nmodule.exports = function requirePackage(name) {\n\tconst entry = require.resolve(name);\n  let dir = path.dirname(entry);\n  while (dir !== '/') {\n    try {\n      const pkg = require(path.join(dir, 'package.json'));\n      return pkg.name === name ? pkg : {};\n    } catch(error) {} // eslint-disable-line no-empty\n    dir = path.dirname(dir);\n  }\n  return {};\n}\n","/home/travis/build/npmtest/node-npmtest-jscodeshift/node_modules/jscodeshift/utils/testUtils.js":"/*\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst mkdirp = require('mkdirp');\nconst path = require('path');\nconst temp = require('temp');\n\nfunction renameFileTo(oldPath, newFilename) {\n  const projectPath = path.dirname(oldPath);\n  const newPath = path.join(projectPath, newFilename);\n  mkdirp.sync(path.dirname(newPath));\n  fs.renameSync(oldPath, newPath);\n  return newPath;\n}\n\nfunction createTempFileWith(content, filename) {\n  const info = temp.openSync();\n  let filePath = info.path;\n  fs.writeSync(info.fd, content);\n  fs.closeSync(info.fd);\n  if (filename) {\n    filePath = renameFileTo(filePath, filename);\n  }\n  return filePath;\n}\nexports.createTempFileWith = createTempFileWith;\n\nfunction createTransformWith(content, fileName) {\n  return createTempFileWith(\n    'module.exports = function(fileInfo, api, options) { ' + content + ' }',\n    fileName\n  );\n}\nexports.createTransformWith = createTransformWith;\n\nfunction getFileContent(filePath) {\n  return fs.readFileSync(filePath).toString();\n}\nexports.getFileContent = getFileContent;\n"}